---
title: "オブジェクト検査と自動復旧"
description: "この記事では、RustFS の単一サーバー複数ディスクアーキテクチャにおけるオブジェクト自己修復（self-healing）機能の設計と実装について紹介します。"
---

# オブジェクト検査と自動復旧

## 概要

RustFS のオブジェクト自己修復機能は、データの整合性と可用性を自動的に維持するための重要な機能です。

## RustFS アーキテクチャと自己修復設計

### 単一サーバー複数ディスクアーキテクチャ

RustFS は単一サーバー複数ディスクの設計を採用し、複数のディスクを一つの論理ストレージプールとして組織化し、オブジェクトストレージサービスを提供します。各オブジェクトは書き込み時に複数のデータシャードと冗長シャードに分割され、異なるディスクに分散配置されることで、信頼性とパフォーマンスを向上させます。

### 自己修復設計原則

1. **データ整合性検証**: チェックサム機構と組み合わせてオブジェクトシャードデータの読み取り時の一貫性を確保
2. **シャード冗長とイレイジャーコーディング**: イレイジャーコーディングで冗長シャードを生成し、一部のデータシャードが失われたり破損した場合に復元
3. **多階層自己修復トリガー**: オンライン修復、バックグラウンドスキャン修復、手動トリガー修復を含む

## オブジェクト自己修復原理

### 検証とイレイジャーコーディング

RustFS はオブジェクト書き込み段階で、オブジェクトを *k* 個のデータシャードと *m* 個の冗長シャードに分割し、指定されたイレイジャーパラメータに従って *n=k+m* 個のブロックデバイスに分散ストレージします。読み取り時にシャードの破損や欠損が発見された場合、他の正常なシャードから再構築できます。

### データ検証と修復（Scrub & Repair）

RustFS はストレージプールに対して定期的に軽量検証（light scrub）と深度検証（deep scrub）を実行：
- **軽量検証**: オブジェクトメタデータとシャードサイズを比較し、破損を発見次第マーク
- **深度検証**: シャードデータをビット単位で読み取りチェックサムを検証、隠れた不良ブロックやbit rotの問題を検出・修復

データスキャンで不整合が発見された場合、RustFS は自動的にRepair処理を呼び出し、破損シャードを冗長シャードで再構築し、修復されたシャードを元のディスクまたは予備ディスクに書き戻します。

## 自己修復フロー

### 読み取り時オンライン自己修復

クライアントが `GET` または `HEAD` リクエストを実行するたび、RustFS は対応するオブジェクトのすべてのデータシャードをまず検査：
1. すべてのデータシャードが正常な場合、データを直接返す
2. シャードの欠損や破損がある場合、冗長シャードから欠損シャードを計算して修復後、完全なオブジェクトをクライアントに返す

### バックグラウンドスキャン自己修復

RustFS には内蔵オブジェクトスキャナがあり、ハッシュ方式でストレージプール内の1/1024のオブジェクトを遍歴して整合性チェックを実行：
- オブジェクトスキャナは定期的（設定可能な頻度）に軽量検証を実行
- 破損が発見された場合、即座に自己修復再構築処理をトリガー

### 手動トリガー自己修復

管理者はコマンドラインツールを通じて全量自己修復を実行可能：

```bash
rc admin heal start --all
```

この操作はストレージプール全体をスキャンし、すべてのオブジェクトに対して完全な検証と修復を実行しますが、リソース消費が大きいため、オフピーク時に慎重に使用する必要があります。

## 使用例

```bash
# 現在の自己修復状態を確認
rc admin heal status
# 指定バケットの自己修復を開始
rc admin heal start --bucket photos
# 進行中の自己修復タスクを停止
rc admin heal stop
```

## まとめ

RustFS のオブジェクト自己修復は、MinIO、Ceph、ZFS などのシステムの成熟した設計を組み合わせ、多階層トリガーの検証と修復処理を通じて、単一マシン複数ディスクおよび複数マシン複数ディスク環境でシャード破損、ディスク障害、bit rot などの問題に効果的に対応し、オブジェクトストレージの高信頼性と高可用性を保障します。

